from __future__ import division
from pyomo.environ import *
import xlrd
from PBUC_data import read_from_excel_1
from PBUC_data import read_from_excel_2 
from PBUC_data import read_from_excel_3
import numpy as np
from pyomo.opt import SolverFactory
import matplotlib.pyplot as plt
import math
import xlsxwriter
import matplotlib.patches as mpatches
import plotly.plotly as py
from plotly.graph_objs import *
import plotly.tools as tls
tls.set_credentials_file(username='sacha_2407', api_key='4lcdwpxoim')





data = read_from_excel_1('data/Personal_data.xlsx')
BELPEX_data = read_from_excel_2('data/spotmarket_data_2016.xls')
reserve_data = read_from_excel_3('data/Reserve_2016.xlsx')


#Day of January used
day = 17 # Start at 0


#Concrete model
model = ConcreteModel()

#Sets
#WARNING : RangeSet start at 1 if not define otherwise
model.Periods = RangeSet(data.nperiods) #time index
model.PeriodsBis = RangeSet(0,data.nperiods)
model.PeriodsBisBis = RangeSet(2,data.nperiods-1)
model.Generators = RangeSet(data.ngenerators) #generators index
model.Pieces = RangeSet(3)


#Variables
#Represent the On/Off status of the generators
model.onOffStatus = Var(model.PeriodsBis, model.Generators, within = Binary)
#Power really generated by the unit
model.powerGen = Var(model.PeriodsBis, model.Generators, within = NonNegativeReals)
#Start-up occured between time t-1 and t
model.startUp = Var(model.Periods, model.Generators, within = Binary)
#Shut-down occured between time t-1 and t
model.shutDown = Var(model.Periods, model.Generators, within = Binary)
# Power generated in the different block by unit by period of time
model.piecesGen = Var(model.Periods, model.Generators,model.Pieces, within = NonNegativeReals)
# 1 if AGC is used in up regulation by unit by period of time
model.onOffUpAGC = Var(model.Periods, model.Generators, within = Binary)
# 1 if AGC is used in down regulation by unit by period of time
model.onOffDownAGC = Var(model.Periods, model.Generators, within = Binary)
# 1 if AGC is used in up or down regulation by unit by period of time
model.onOffAGC = Var(model.Periods, model.Generators, within = Binary)
#Power bid in Up regulation by unit by period of time
model.AGCup =  Var(model.Periods, model.Generators, within = NonNegativeReals)
#Power bid in Down regulation by unit by period of time
model.AGCdown =  Var(model.Periods, model.Generators, within = NonNegativeReals)


#These two equations are mandatory to force the value of the variable shut down in an acceptable range !
def shutdown_test1_rule(model,i,j):
		return model.shutDown[i,j] <= 1
model.shutdown_test1 = Constraint(model.Periods, model.Generators, rule = shutdown_test1_rule)

def shutdown_test2_rule(model,i,j):
		return model.shutDown[i,j] >= 0
model.shutdown_test2 = Constraint(model.Periods, model.Generators, rule = shutdown_test2_rule)

#WARNING : Data start at 0 and variable at 1 (CFR. RangeSet)
#Constraints
def power_init_rule(model,j):
		return model.powerGen[0,j] == data.powerInit[j-1]
model.power_init = Constraint(model.Generators, rule=power_init_rule)

def onOff_init_rule(model,j):
		return model.onOffStatus[0,j] == data.onOffInit[j-1]
model.onOff_init = Constraint(model.Generators, rule=onOff_init_rule)


#Bid constraint
#WARNING : Do not put two inequality in the same equation SEPARATE THEM!
def power_limit1_rule(model,i,j):
		return model.powerGen[i,j] <= model.onOffStatus[i,j]*data.powerMax[j-1] - model.onOffUpAGC[i,j]*model.AGCup[i,j]
def power_limit2_rule(model,i,j):
		return model.onOffStatus[i,j]*data.powerMin[j-1] + model.onOffDownAGC[i,j]*model.AGCdown[i,j] <= model.powerGen[i,j]
model.power_limit1 = Constraint(model.Periods,model.Generators, rule=power_limit1_rule)
model.power_limit2 = Constraint(model.Periods,model.Generators, rule=power_limit2_rule)


def ramp_up_rule(model,i,j):
		return (model.powerGen[i,j] - model.powerGen[i-1,j]) <= data.rampUpLim[j-1]*data.periodDuration *(1-model.onOffAGC[i,j])
def ramp_down_rule(model,i,j):
		return (model.powerGen[i-1,j] - model.powerGen[i,j]) <= data.rampDownLim[j-1]*data.periodDuration * (1 - model.onOffAGC[i,j])
model.ramp_up = Constraint(model.Periods, model.Generators, rule=ramp_up_rule)
model.ramp_down = Constraint(model.Periods, model.Generators, rule=ramp_down_rule)

def up_down1_rule(model,i,j):
		return (model.startUp[i,j] - model.shutDown[i,j]) == (model.onOffStatus[i,j] - model.onOffStatus[i-1,j])
def up_down2_rule(model,i,j):
		return (model.startUp[i,j] + model.shutDown[i,j]) <= 1
model.up_down1 = Constraint(model.Periods, model.Generators, rule=up_down1_rule)
model.up_down2 = Constraint(model.Periods, model.Generators, rule=up_down2_rule)



#-------------------
#UP-TIME CONSTRAINTS
#-------------------
def initial_time_periods_online_rule(m, j):
   if not data.onOffInit[j-1]:
      return 0
   else:
      
      #print int((data.minUpTime[j-1]/data.periodDuration - data.countInit[j-1]/data.periodDuration)* model.onOffStatus[0,j])
      return int(max(0,min(data.nperiods, (data.minUpTime[j-1]/data.periodDuration - data.countInit[j-1]/data.periodDuration)* data.onOffInit[j-1])))

model.InitialTimePeriodsOnLine = Param(model.Generators, within=NonNegativeIntegers, initialize=initial_time_periods_online_rule)

# constraint due to initial conditions.
def enforce_up_time_constraints_initial(m, j):
   if value(m.InitialTimePeriodsOnLine[j]) is 0:
      return Constraint.Skip
   return sum((1-m.onOffStatus[i, j]) for i in m.Periods if i <= value(m.InitialTimePeriodsOnLine[j])) == 0.0
   
model.EnforceUpTimeConstraintsInitial = Constraint(model.Generators, rule=enforce_up_time_constraints_initial)

# constraint for each time period after that not involving the initial condition.
def enforce_up_time_constraints_subsequent(m, j, i):
   if i <= value(m.InitialTimePeriodsOnLine[j]):
      #already treated
      return Constraint.Skip
   elif (i >= value(m.InitialTimePeriodsOnLine[j])+1 and i <= data.nperiods ):
        return m.startUp[i,j] + sum(m.shutDown[n,j] for n in m.Periods if n >= i+1 and n <= min(data.nperiods, i + data.minUpTime[j-1]/data.periodDuration-1)) <= 1.0 


model.EnforceUpTimeConstraintsSubsequent = Constraint( model.Generators,model.Periods, rule=enforce_up_time_constraints_subsequent)


#--------------------
#DOWN-TIME CONSTRAINT
#--------------------

def initial_time_periods_offline_rule(m, j):
   if data.onOffInit[j-1]:
      return 0
   else:
      return int(max(0,min(data.nperiods, (data.minDownTime[j-1]/data.periodDuration - data.countInit[j-1]/data.periodDuration)* (1-data.onOffInit[j-1]))))

model.InitialTimePeriodsOffLine = Param(model.Generators, within=NonNegativeIntegers, initialize=initial_time_periods_offline_rule)

# constraint due to initial conditions.
def enforce_down_time_constraints_initial(m, j):
   if value(m.InitialTimePeriodsOffLine[j]) is 0:
      return Constraint.Skip
   return sum(m.onOffStatus[i, j] for i in m.Periods if i <= value(m.InitialTimePeriodsOffLine[j])) == 0.0
   
model.EnforceDownTimeConstraintsInitial = Constraint(model.Generators, rule=enforce_down_time_constraints_initial)


# constraint for each time period after that not involving the initial condition.
def enforce_down_time_constraints_subsequent(m, j, i):
   if i <= value(m.InitialTimePeriodsOffLine[j]):
      #already treated
      return Constraint.Skip
   elif (i >= value(m.InitialTimePeriodsOffLine[j])+1 and i <= (data.nperiods)):
        return m.shutDown[i,j] + sum(m.startUp[n,j] for n in m.Periods if n >= i+1 and n <= min(data.nperiods, i + data.minDownTime[j-1]/data.periodDuration -1)) <= 1.0 



model.EnforceDownTimeConstraintsSubsequent = Constraint( model.Generators,model.Periods, rule=enforce_down_time_constraints_subsequent)


#----------------------
# COST-CURVE Constraint
#----------------------

def power_generated_rule(m,j,i):
	return model.powerGen[i,j] == sum(model.piecesGen[i,j,l] for l in model.Pieces) + model.onOffStatus[i,j]*data.powerMin[j-1]
model.power_generated = Constraint(model.Generators, model.Periods, rule=power_generated_rule)

def power_piece_min_rule(m,j,i):
	return model.piecesGen[i,j,1] <= data.rangeCost[j-1][0]-data.powerMin[j-1]
model.power_piece_min = Constraint(model.Generators, model.Periods, rule=power_piece_min_rule)

def power_piece_middle_rule(m,j,i):
	return model.piecesGen[i,j,2] <= data.rangeCost[j-1][1]-data.rangeCost[j-1][0]
model.power_piece_middle = Constraint(model.Generators, model.Periods, rule=power_piece_middle_rule)

def power_piece_up_rule(m,j,i):
	return model.piecesGen[i,j,3] <= data.powerMax[j-1]-data.rangeCost[j-1][1]
model.power_piece_up = Constraint(model.Generators, model.Periods, rule=power_piece_up_rule)


#--------------------
# RESERVE Constraint
#--------------------


#Bid constraint
def onOff_up_AGC_constrained_rule(m,j,i):
	return model.onOffStatus[i,j] >= model.onOffUpAGC[i,j]
model.onOff_up_AGC_constrained = Constraint(model.Generators, model.Periods, rule=onOff_up_AGC_constrained_rule)


def onOff_down_AGC_constrained_rule(m,j,i):
	return model.onOffStatus[i,j] >= model.onOffDownAGC[i,j]
model.onOff_down_AGC_constrained = Constraint(model.Generators, model.Periods, rule=onOff_down_AGC_constrained_rule)


def onOff_AGC_constrained_1_rule(m,j,i):
	return model.onOffAGC[i,j] >= model.onOffUpAGC[i,j]
model.onOff_AGC_constrained_1 = Constraint(model.Generators, model.Periods, rule=onOff_AGC_constrained_1_rule)

def onOff_AGC_constrained_2_rule(m,j,i):
	return model.onOffAGC[i,j] >= model.onOffDownAGC[i,j]
model.onOff_AGC_constrained_2 = Constraint(model.Generators, model.Periods, rule=onOff_AGC_constrained_2_rule)



def maximum_reserve_capacity_up_regulation_rule(m,i):
	return sum(model.AGCup[i,j] for j in model.Generators) <= BELPEX_data.AGC_capacity
model.maximum_reserve_capacity_up_regulation = Constraint(model.Periods, rule=maximum_reserve_capacity_up_regulation_rule)

def maximum_reserve_capacity_down_regulation_rule(m,i):
	return sum(model.AGCdown[i,j] for j in model.Generators) <= BELPEX_data.AGC_capacity
model.maximum_reserve_capacity_down_regulation = Constraint(model.Periods, rule=maximum_reserve_capacity_down_regulation_rule)


#Bid Constraint
def link_onOffAGC_AGcapacity_up_regulation_rule(m,j,i):
	return BELPEX_data.AGC_capacity* model.onOffUpAGC[i,j] >= model.AGCup[i,j]
model.link_onOffAGC_AGcapacity_up_regulation = Constraint(model.Generators, model.Periods, rule=link_onOffAGC_AGcapacity_up_regulation_rule)

def link_onOffAGC_AGcapacity_down_regulation_rule(m,j,i):
	return BELPEX_data.AGC_capacity* model.onOffDownAGC[i,j] >= model.AGCdown[i,j]
model.link_onOffAGC_AGcapacity_down_regulation = Constraint(model.Generators, model.Periods, rule=link_onOffAGC_AGcapacity_down_regulation_rule)




def constraint_AGcapacity_up_regulation_rule(m,j,i):
	return data.rampUpLim[j-1] >= model.AGCup[i,j]*8
model.constraint_AGcapacity_up_regulation = Constraint(model.Generators, model.Periods, rule=constraint_AGcapacity_up_regulation_rule)

def constraint_AGcapacity_down_regulation_rule(m,j,i):
	return data.rampDownLim[j-1] >= model.AGCdown[i,j]*8
model.constraint_AGcapacity_down_regulation = Constraint(model.Generators, model.Periods, rule=constraint_AGcapacity_down_regulation_rule)



def total_up_regulation_rule(m,i):
	return sum(model.AGCup[i,j] for j in model.Generators)  == sum(model.AGCup[i+1,j] for j in model.Generators) 
model.total_up_regulation = Constraint(model.PeriodsBisBis, rule=total_up_regulation_rule)

def total_down_regulation_rule(m,i):
	return sum(model.AGCdown[i,j] for j in model.Generators)  == sum(model.AGCdown[i+1,j] for j in model.Generators) 
model.total_down_regulation = Constraint(model.PeriodsBisBis, rule=total_down_regulation_rule)



def minimum_bid_up_reserve_rule(m,j,i):
	return model.onOffUpAGC[i,j]*1 <= model.AGCup[i,j]
model.minimum_bid_up_reserve = Constraint(model.Generators, model.Periods, rule=minimum_bid_up_reserve_rule)

def minimum_bid_down_reserve_rule(m,j,i):
	return model.onOffDownAGC[i,j]*1 <= model.AGCdown[i,j]
model.minimum_bid_down_reserve = Constraint(model.Generators, model.Periods, rule=minimum_bid_down_reserve_rule)


# Objective
def obj_cost(model):


		return sum(sum(data.periodDuration*(BELPEX_data.AGC_price*model.AGCup[i,j]+BELPEX_data.AGC_price*model.AGCdown[i,j]+BELPEX_data.price[day][int(math.ceil(i/4)-1)] * model.powerGen[i,j]) - (data.periodDuration*data.fixedCost[j-1]*model.onOffStatus[i,j] + model.startUp[i,j]*data.startUpCost[j-1] +\
				data.periodDuration*data.powerCost[j-1][0]*data.powerMin[j-1]*model.onOffStatus[i,j] +sum(data.periodDuration*data.powerCost[j-1][l-1]*model.piecesGen[i,j,l] for l in model.Pieces)) for j in model.Generators) for i in model.Periods)

model.obj = Objective(rule=obj_cost, sense=maximize)


if __name__ == '__main__':

	


	opt = SolverFactory("gurobi")
	results = opt.solve(model, tee=True, keepfiles=True)
	print("")
	print ("Day %s" %(day+1))
	print("Global profit: %s" %model.obj()) 



powgen = np.array(np.asarray([[round(model.powerGen[i,j].value,8) for j in model.Generators] for i in model.Periods]))
powgentot = np.asarray([sum(model.powerGen[i,j].value for j in model.Generators) for i in model.Periods])
onOff = np.array(np.asarray([[model.onOffStatus[i,j].value for j in model.Generators] for i in model.Periods]))

startUp = np.array(np.asarray([[model.startUp[i,j].value for j in model.Generators] for i in model.Periods]))
shutDown = np.array(np.asarray([[model.shutDown[i,j].value for j in model.Generators] for i in model.Periods]))


piecesGen = np.array(np.asarray([[[model.piecesGen[i,j,l].value for l in model.Pieces] for j in model.Generators]for i in model.Periods])) 




onOffAGC = np.array(np.asarray([[model.onOffAGC[i,j].value for j in model.Generators] for i in model.Periods]))
AGCup = np.array(np.asarray([[round(model.AGCup[i,j].value,8) for j in model.Generators] for i in model.Periods]))
AGCdown = np.array(np.asarray([[round(model.AGCdown[i,j].value,8) for j in model.Generators] for i in model.Periods]))
AGCuptot = np.array(np.asarray([sum(model.AGCup[i,j].value for j in model.Generators) for i in model.Periods]))
AGCdowntot = np.array(np.asarray([sum(model.AGCdown[i,j].value for j in model.Generators) for i in model.Periods]))


price = np.array(np.asarray([[BELPEX_data.price[j][i] for i in range(24)] for j in range(31+25)]))



#Reserve profit
#--------------

Reserve_profit = sum(sum(data.periodDuration*(BELPEX_data.AGC_price*AGCup[i-1,j-1]+BELPEX_data.AGC_price*AGCdown[i-1,j-1]) for j in model.Generators)for i in model.Periods)

print("Reserve profit: %s" %Reserve_profit) 


#Day-ahead profit
#----------------

Day_ahead_profit_pos = sum(sum(data.periodDuration*(BELPEX_data.price[day][int(math.ceil(i/4)-1)] * powgen[i-1,j-1]) for j in model.Generators) for i in model.Periods)

Day_ahead_profit_neg = sum(sum(data.periodDuration*data.powerCost[j-1][0]*data.powerMin[j-1]*onOff[i-1,j-1] +sum(data.periodDuration*data.powerCost[j-1][l-1]*piecesGen[i-1,j-1,l-1] for l in model.Pieces) for j in model.Generators) for i in model.Periods)

print("Day-ahead profit tot: %s" %(Day_ahead_profit_pos - Day_ahead_profit_neg)) 
print("")



print("Up-regulation : %s" %AGCuptot)
print("Down-regulation : %s" %AGCdowntot)

print("")



hour = np.linspace(0,24,96)


plt.figure()
plt.plot(hour,powgentot,color='g', label="Power generated")
plt.plot(hour,AGCuptot,color='r', label ="Up regulation", linewidth=2.0)
plt.plot(hour,AGCdowntot, label ="Down regulation")
plt.legend(loc = 'upper left')
plt.xlabel("Time [hour]")
plt.ylabel("Quantity [MWh]" )
plt.axis([0, 24, 0, sum(data.powerMax[j-1] for j in model.Generators)+200 ])
plt.savefig("State of the system.pdf")




plt.figure()
plt.plot(price[0,:])
plt.xlabel("Time [hours]")
plt.ylabel("Price [euro/MWh]")
plt.axis([0, 23, 0, 150])
plt.savefig("Prices_1th_jan.pdf")


plt.figure()
for i in range(31):
	plt.plot(price[i,:])
plt.xlabel("Time [hours]")
plt.ylabel("Price [euro/MWh]")
plt.axis([0, 23, 0, 150])
plt.savefig("Prices.pdf")




plt.figure()
plt.plot(price[17,:])
plt.plot(price[18,:])
plt.plot(price[19,:])
plt.plot(price[20,:])
plt.plot(price[21,:])
plt.xlabel("Time [hours]")
plt.ylabel("Price [euro/MWh]")
plt.axis([0, 23, 0, 150])
plt.savefig("Prices_CCGT_work.pdf")



#----------------------
#Constuction of the bid
#----------------------



def continuous_bid_pricing(power,j):
	if power == 0.0:
		return float("inf")
	elif power >= data.powerMin[j] and power < data.rangeCost[j][0] :
		return (data.fixedCost[j] + data.powerCost[j][0]*power)/power 
	elif power >= data.rangeCost[j][0] and power < data.rangeCost[j][1] :
		return (data.fixedCost[j] + data.powerCost[j][0]*data.rangeCost[j][0] + data.powerCost[j][1]*(power-data.rangeCost[j][0]) )/power
	elif power <= data.powerMax[j] and power >= data.rangeCost[j][1]:
		return (data.fixedCost[j] + data.powerCost[j][0]*data.rangeCost[j][0] + data.powerCost[j][1]*(data.rangeCost[j][1]-data.rangeCost[j][0]) + data.powerCost[j][2]*(power-data.rangeCost[j][1]) )/power
		




epsilon = 0.000001 # Needed to bid the block bid at a lower price than the continuous bid to ensure that it be taken before

block_bid = np.zeros((data.nperiods,data.ngenerators))
continuous_bid = np.zeros((data.nperiods,data.ngenerators))
price_block_bid = np.zeros((data.nperiods,data.ngenerators))
price_continuous_bid = np.zeros((data.nperiods,data.ngenerators))


workbook = xlsxwriter.Workbook('data/Bids_created.xlsx')
bidssheet = workbook.add_worksheet('offers')
ranksheet = workbook.add_worksheet('rank')

nb_bids = 0
nb_continuous_bid = 0


for i in range(data.nperiods):
	for j in range(data.ngenerators):
		
		if powgen[i,j] != 0:
			nb_bids = nb_bids + 1
			bidssheet.write(nb_bids-1, 4, j)
			bidssheet.write(nb_bids-1, 3, i)

			#Category 1
			if data.fixedCost[j] == 0:
				if (powgen[i,j] > data.powerMin[j]):
					block_bid[i,j] = data.powerMin[j]
					if BELPEX_data.price[day][int(math.floor(i/4))] >= continuous_bid_pricing(data.powerMin[j],j):
						price_block_bid[i,j] = continuous_bid_pricing(data.powerMin[j],j) - epsilon #Remplacer powgen par PowerMin ? 
					else:
						price_block_bid[i,j] = 0
					bidssheet.write(nb_bids-1, 0, block_bid[i,j])
					bidssheet.write(nb_bids-1, 1, price_block_bid[i,j])
					bidssheet.write(nb_bids-1, 2, 2)  #Type 2 : Block bids

					nb_bids = nb_bids + 1
					nb_continuous_bid = nb_continuous_bid + 1
					bidssheet.write(nb_bids-1, 4, j)
					bidssheet.write(nb_bids-1, 3, i)

					continuous_bid[i,j] = powgen[i,j]-data.powerMin[j]
					if BELPEX_data.price[day][int(math.floor(i/4))] >= continuous_bid_pricing(powgen[i,j],j):
						price_continuous_bid[i,j] = continuous_bid_pricing(powgen[i,j],j) # Price per MWH
					else:
						price_continuous_bid[i,j] = 0
					bidssheet.write(nb_bids-1, 0, continuous_bid[i,j])
					bidssheet.write(nb_bids-1, 1, price_continuous_bid[i,j])
					bidssheet.write(nb_bids-1, 2, 1)  #Type 1 : Continuous bids

				elif (powgen[i,j] == data.powerMin[j]):
					block_bid[i,j] = data.powerMin[j]
					if BELPEX_data.price[day][int(math.floor(i/4))] >= continuous_bid_pricing(powgen[i,j],j):
						price_block_bid[i,j] = continuous_bid_pricing(powgen[i,j],j) 
					else:
						price_block_bid[i,j] = 0
					bidssheet.write(nb_bids-1, 0, block_bid[i,j])
					bidssheet.write(nb_bids-1, 1, price_block_bid[i,j])
					bidssheet.write(nb_bids-1, 2, 2)  #Type 2 : Block bids


			#Category 2
			else:
				if (powgen[i,j] >= data.powerMin[j]):
					block_bid[i,j] = powgen[i,j]
					if BELPEX_data.price[day][int(math.floor(i/4))] >= continuous_bid_pricing(powgen[i,j],j):
						price_block_bid[i,j] = continuous_bid_pricing(powgen[i,j],j)
					else:
						price_block_bid[i,j] = 0
					bidssheet.write(nb_bids-1, 0, block_bid[i,j])
					bidssheet.write(nb_bids-1, 1, price_block_bid[i,j])
					bidssheet.write(nb_bids-1, 2, 2)  #Type 2 : Block bids


bidssheet.write(0, 6, nb_bids)
bidssheet.write(0, 7, day)

price_max_quantity = np.zeros(data.ngenerators)

for j in range(data.ngenerators):
	price_max_quantity[j] = continuous_bid_pricing(data.powerMax[j],j)



# Number of the powerplant going from the cheaper to the more expensive
indexranks = price_max_quantity.argsort()

for j in range(data.ngenerators):
	ranksheet.write(0, j, indexranks[j])
	ranksheet.write(1, j, data.powerMax[j])
	ranksheet.write(2, j, price_max_quantity[j])


#----------------------------------
# SETTLEMENT OF THE IMBALANCE PRICE
#----------------------------------

price_up_regulation_global = np.zeros(data.nperiods)
price_down_regulation_global = np.zeros(data.nperiods)
imbalance_price = np.zeros(data.nperiods)
NRV = np.zeros(data.nperiods)

up_activated = np.array(np.asarray([[reserve_data.up_activated[j][i] for i in range(96)] for j in range(31)]))
down_activated = np.array(np.asarray([[reserve_data.down_activated[j][i] for i in range(96)] for j in range(31)]))

price_up_regulation = []
price_down_regulation = []
quantity_up_regulation = []
quantity_down_regulation = []

for i in range(data.nperiods):
	price_up_regulation.append([])
	quantity_up_regulation.append([])
	price_down_regulation.append([])
	quantity_down_regulation.append([])


for i in range(data.nperiods):
	temp1 = 0
	temp2 = 0
	for j in range(data.ngenerators):
		if AGCup[i,j] != 0:
			price_up_regulation[i].append(continuous_bid_pricing(powgen[i,j]+AGCup[i,j],j))
			quantity_up_regulation[i].append(AGCup[i,j])
			temp1 = 1
		if AGCdown[i,j] != 0:
			price_down_regulation[i].append(continuous_bid_pricing(powgen[i,j]-AGCdown[i,j],j))
			quantity_down_regulation[i].append(AGCdown[i,j])
			temp2 = 1
	if temp1 == 0:
			price_up_regulation[i].append(0)
			quantity_up_regulation[i].append(0)
	if temp2 == 0:
			price_down_regulation[i].append(0)
			quantity_down_regulation[i].append(0)




for i in range(data.nperiods):
	price_up_regulation_temp = np.asarray(price_up_regulation[i])
	quantity_up_regulation_temp = np.asarray(quantity_up_regulation[i])
	price_down_regulation_temp = np.asarray(price_down_regulation[i])
	quantity_down_regulation_temp = np.asarray(quantity_down_regulation[i])

	NRV[i] = up_activated[day,i]-down_activated[day,i]
	rank_up = price_up_regulation_temp.argsort()

	rank_down = (-price_down_regulation_temp).argsort() #Do not forget to take the higher cost in priority for down-regulation
	if price_up_regulation_temp[0] == 0:
		price_up_regulation_global[i] = 100
	else:
		quantity_up_reserved = 0
		for r in rank_up:
			if up_activated[day,i] <= quantity_up_reserved + quantity_up_regulation_temp[r]:
				price_up_regulation_global[i] = price_up_regulation_temp[r]
				break
			else : 
				quantity_up_reserved = quantity_up_reserved + quantity_up_regulation_temp[r]
	if price_down_regulation_temp[0] == 0:
		price_down_regulation_global[i] = 100
	else:
		quantity_up_reserved = 0
		quantity_down_reserved = 0
		for r in rank_down:
			if down_activated[day,i] <= quantity_down_reserved + quantity_down_regulation_temp[r]:
				price_down_regulation_global[i] = price_down_regulation_temp[r]
				break
			else : 
				quantity_down_reserved = quantity_down_reserved + quantity_down_regulation_temp[r]

	if up_activated[day,i] > down_activated[day,i]:
		imbalance_price[i] = price_up_regulation_global[i]

	elif up_activated[day,i] < down_activated[day,i]:
		imbalance_price[i] = price_down_regulation_global[i]
	else:
		imbalance_price[i] = 0









#-----
#PRINT
#-----



#PLOT IMBALANCE PRICES

colors = []

for i in range(data.nperiods):
	if imbalance_price[i] == 100:
		colors.append('0.70')
	elif up_activated[day,i] > down_activated[day,i]:
		colors.append('r')
	elif up_activated[day,i] <= down_activated[day,i]:
		colors.append('b')
recs = []
plt.figure()
classes = ["Up-regulation", "Down-regulation", "Default"]
class_colours = ['r', 'b','0.70']
width = 0.25
plt.bar(hour,imbalance_price,width, color=colors)
plt.xlim(0,24)
plt.ylim(0,110)
plt.ylabel("Imbalance price ["+u"\u20AC]")
plt.xlabel("Hour [h]")
for i in range(0,len(class_colours)):
    recs.append(mpatches.Rectangle((0,0),1,1,fc=class_colours[i]))
plt.legend(recs,classes,loc='upper left')
plt.savefig("Imbalance_price.pdf")

#PLOT NRV

plt.figure()
plt.plot(hour,NRV,linewidth=2.0)
plt.plot(np.zeros(25), color = 'k')
plt.plot(hour,NRV,'bo')
plt.xlabel("Hour [h]")
plt.ylabel("Net regulation volume [MW]")
plt.xlim(0,24)
plt.ylim(-100,100)
plt.savefig("NRV.pdf")




#PLOT COST CURVE

x = np.linspace(0, 500, 1000)

j=1

z = np.zeros((len(x),1))
for i in range(len(x)):
	z[i] = continuous_bid_pricing(x[i],j)

j = 2

z2 = np.zeros((len(x),1))
for i in range(len(x)):
	z2[i] = continuous_bid_pricing(x[i],j)


plt.figure()
plt.plot(x,z, label= "Category 1")
plt.plot(x,z2,label= "Category 2")
plt.legend()
plt.xlabel("Power generated [MW]")
plt.ylabel("Cost curve [euro/MWh]")
plt.grid(True)
plt.xlim(data.powerMin[j], data.powerMax[j])
plt.savefig("Cost_curve.pdf")


# Plot relay between power plants


if(0):
	trace1 = Bar(
	    x=hour,
	    y=AGCup[:,0],
	    name='Generator 1'
	)
	trace2 = Bar(
	    x=hour,
	    y=AGCup[:,1],
	    name='Generator 2'
	)
	trace3 = Bar(
	    x=hour,
	    y=AGCup[:,2],
	    name='Generator 3'
	)
	trace4 = Bar(
	    x=hour,
	    y=AGCup[:,3],
	    name='Generator 4'
	)
	trace5 = Bar(
	    x=hour,
	    y=AGCup[:,4],
	    name='Generator 5'
	)
	trace6 = Bar(
	    x=hour,
	    y=AGCup[:,5],
	    name='Generator 6'
	)
	trace7 = Bar(
	    x=hour,
	    y=AGCup[:,6],
	    name='Generator 7'
	)
	trace8 = Bar(
	    x=hour,
	    y=AGCup[:,7],
	    name='Generator 8'
	)
	trace9 = Bar(
	    x=hour,
	    y=AGCup[:,8],
	    name='Generator 9'
	)
	trace10 = Bar(
	    x=hour,
	    y=AGCup[:,9],
	    name='Generator 10'
	)
	trace11 = Bar(
	    x=hour,
	    y=AGCup[:,10],
	    name='Generator 11'
	)
	data = [trace1, trace2, trace3, trace4, trace5, trace6, trace7, trace8, trace9, trace10,trace11]
	layout = Layout(
		font=Font(
	        size=18
    	),
		autosize=False,
	    barmode='stack',
	    yaxis = YAxis(title='Capacity allows to up-regulation [MW]' ),
	    xaxis = XAxis(title ='Time [hours]'),
	   	width=1500,
	    height=640
	)

	fig = Figure(data=data, layout=layout)
	plot_url = py.plot(fig, filename='stacked-bar-up-regulation')

	trace1 = Bar(
	    x=hour,
	    y=AGCdown[:,0],
	    name='Generator 1'
	)
	trace2 = Bar(
	    x=hour,
	    y=AGCdown[:,1],
	    name='Generator 2'
	)
	trace3 = Bar(
	    x=hour,
	    y=AGCdown[:,2],
	    name='Generator 3'
	)
	trace4 = Bar(
	    x=hour,
	    y=AGCdown[:,3],
	    name='Generator 4'
	)
	trace5 = Bar(
	    x=hour,
	    y=AGCdown[:,4],
	    name='Generator 5'
	)
	trace6 = Bar(
	    x=hour,
	    y=AGCdown[:,5],
	    name='Generator 6'
	)
	trace7 = Bar(
	    x=hour,
	    y=AGCdown[:,6],
	    name='Generator 7'
	)
	trace8 = Bar(
	    x=hour,
	    y=AGCdown[:,7],
	    name='Generator 8'
	)
	trace9 = Bar(
	    x=hour,
	    y=AGCdown[:,8],
	    name='Generator 9'
	)
	trace10 = Bar(
	    x=hour,
	    y=AGCdown[:,9],
	    name='Generator 10'
	)
	trace11 = Bar(
	    x=hour,
	    y=AGCdown[:,10],
	    name='Generator 11'
	)
	data = [trace1, trace2, trace3, trace4, trace5, trace6, trace7, trace8, trace9, trace10,trace11]
	layout = Layout(
		font=Font(
	        size=18
    	),
		autosize=False,
	    barmode='stack',
	    yaxis = YAxis(title='Capacity allows to down-regulation [MW]' ),
	    xaxis = XAxis(title ='Time [hours]'),
	    width=1500,
	    height=640

	)

	fig = Figure(data=data, layout=layout)
	plot_url = py.plot(fig, filename='stacked-bar-down-regulation')


